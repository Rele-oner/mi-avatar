<!DOCTYPE html>
<html>
<head>
    <title>Mi Avatar - Corrección de Brazos</title>
    <style>
        body { margin: 0; background-color: #00ff00; overflow: hidden; }
        #webcam { position: absolute; bottom: 10px; right: 10px; width: 160px; transform: scaleX(-1); border: 2px solid white; border-radius: 5px; }
        #status { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.5); padding: 8px; font-family: sans-serif; }
    </style>
</head>
<body>
    <div id="status">Calibrando brazos...</div>
    <video id="webcam" autoplay playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const videoElement = document.getElementById('webcam');
        const status = document.getElementById('status');

        const scene = new THREE.Scene();
        const camera3D = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const material = new THREE.MeshNormalMaterial();
        const avatar = new THREE.Group();
        
        // Cabeza
        const cabeza = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.5, 0.3), material);
        avatar.add(cabeza);

        // Tronco
        const tronco = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.8, 0.25), material);
        tronco.position.y = -0.7;
        avatar.add(tronco);

        // Brazos con pivote corregido
        const brazoGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.6);
        brazoGeo.translate(0, -0.3, 0); // El punto de giro ahora es el extremo superior (hombro)

        const brazoD = new THREE.Mesh(brazoGeo, material);
        brazoD.position.set(-0.35, -0.4, 0);
        avatar.add(brazoD);

        const brazoI = new THREE.Mesh(brazoGeo, material);
        brazoI.position.set(0.35, -0.4, 0);
        avatar.add(brazoI);

        scene.add(avatar);
        camera3D.position.set(0, -0.5, 2.5);

        const holistic = new Holistic({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`});
        holistic.setOptions({ modelComplexity: 1, refineFaceLandmarks: true });

        holistic.onResults((results) => {
            status.innerText = "Tracking: ACTIVO";
            
            if (results.faceLandmarks) {
                const n = results.faceLandmarks[1];
                cabeza.rotation.y = (n.x - 0.5) * -1.5;
                cabeza.rotation.x = (n.y - 0.5) * 1.5;
            }

            if (results.poseLandmarks) {
                const hD = results.poseLandmarks[12]; 
                const cD = results.poseLandmarks[14]; 
                const hI = results.poseLandmarks[11]; 
                const cI = results.poseLandmarks[13]; 

                // MATEMÁTICAS CORREGIDAS: Invertimos el cálculo del ángulo
                // Brazo Derecho
                const anguloD = Math.atan2(cD.y - hD.y, cD.x - hD.x);
                brazoD.rotation.z = anguloD - Math.PI / 2;

                // Brazo Izquierdo
                const anguloI = Math.atan2(cI.y - hI.y, cI.x - hI.x);
                brazoI.rotation.z = anguloI - Math.PI / 2;
            }
        });

        const camera = new Camera(videoElement, {
            onFrame: async () => { await holistic.send({image: videoElement}); },
            width: 640, height: 480
        });
        camera.start();

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera3D);
        }
        animate();
    </script>
</body>
</html>
