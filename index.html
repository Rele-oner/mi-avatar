<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>AI Avatar - V21 Stable</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', monospace; color: #00ffcc; }
        .app-container { display: flex; width: 100vw; height: 100vh; }
        .sidebar { width: 220px; background: rgba(0,20,20,0.9); border-right: 1px solid #00ffcc44; padding: 30px 20px; z-index: 10; }
        .main-view { flex: 1; position: relative; }
        canvas { width: 100%; height: 100%; transform: rotateY(180deg); object-fit: contain; }
        video { display: none; }
        .stat { margin-bottom: 20px; border-left: 2px solid #00ffcc; padding-left: 10px; }
        .label { font-size: 10px; opacity: 0.6; text-transform: uppercase; }
        .val { font-size: 14px; font-weight: bold; }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="sidebar">
            <div class="stat"><div class="label">Engine_Link</div><div class="val" id="st">READY</div></div>
            <div class="stat"><div class="label">Perf_Monitor</div><div class="val" id="fps">0 FPS</div></div>
            <div class="stat"><div class="label">Iris_Sync</div><div class="val" id="iris">WAITING</div></div>
        </div>
        <div class="main-view">
            <canvas id="out"></canvas>
            <video id="v" playsinline></video>
        </div>
    </div>

<script type="module">
    const video = document.getElementById('v');
    const canvas = document.getElementById('out');
    const ctx = canvas.getContext('2d');
    let themeColor = '#00ffcc';
    let lastTime = 0;
    let isProcessing = false;

    function onResults(res) {
        // Ajuste dinámico de resolución para evitar lag
        if (canvas.width !== video.videoWidth) {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Renderizado del "Iris Protocol" (Solo centros para máxima velocidad)
        if (res.faceLandmarks) {
            const eyes = [468, 473]; 
            eyes.forEach(i => {
                const p = res.faceLandmarks[i];
                ctx.beginPath();
                ctx.arc(p.x * canvas.width, p.y * canvas.height, 4, 0, 7);
                ctx.fillStyle = '#fff';
                ctx.shadowBlur = 10; ctx.shadowColor = themeColor;
                ctx.fill();
            });
            // Dibujamos solo el contorno esencial
            drawConnectors(ctx, res.faceLandmarks, FACEMESH_FACE_OVAL, {color: themeColor, lineWidth: 2});
            document.getElementById('iris').innerText = "LOCKED";
        }

        // Renderizado simplificado de cuerpo y manos
        const drawOpts = {color: themeColor, lineWidth: 2};
        if (res.poseLandmarks) drawConnectors(ctx, res.poseLandmarks, POSE_CONNECTIONS, drawOpts);
        if (res.leftHandLandmarks) drawConnectors(ctx, res.leftHandLandmarks, HAND_CONNECTIONS, {color: '#fff', lineWidth: 1.5});
        if (res.rightHandLandmarks) drawConnectors(ctx, res.rightHandLandmarks, HAND_CONNECTIONS, {color: '#fff', lineWidth: 1.5});

        // Monitor de rendimiento
        const now = performance.now();
        document.getElementById('fps').innerText = Math.round(1000 / (now - lastTime)) + " FPS";
        lastTime = now;
        document.getElementById('st').innerText = "RUNNING";
        
        isProcessing = false; // Liberar para el siguiente frame
    }

    const holistic = new Holistic({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${f}`});
    
    // CONFIGURACIÓN DE ALTO RENDIMIENTO
    holistic.setOptions({
        modelComplexity: 0, // El nivel más rápido disponible
        smoothLandmarks: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    holistic.onResults(onResults);

    const camera = new Camera(video, {
        onFrame: async () => {
            if (isProcessing) return; // Si el modelo sigue ocupado, saltar este frame
            isProcessing = true;
            await holistic.send({image: video});
        },
        width: 640, height: 480 // Resolución interna reducida para fluidez total
    });
    
    camera.start().catch(() => {
        document.getElementById('st').innerText = "ERROR_CAMERA";
    });
</script>
</body>
</html>
