<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>AI Avatar - Precision Mesh Engine</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; background: #000; color: #00ffcc; font-family: 'Courier New', monospace; overflow: hidden; }
        .container { display: flex; width: 100vw; height: 100vh; padding: 20px; box-sizing: border-box; gap: 20px; }
        .canvas-container { position: relative; flex: 1; background: #080808; border: 1px solid #1a1a1a; border-radius: 15px; overflow: hidden; }
        video { display: none; }
        canvas { width: 100%; height: 100%; transform: rotateY(180deg); object-fit: contain; }
        .status-bar { position: absolute; top: 20px; left: 20px; background: rgba(0, 255, 204, 0.1); padding: 5px 15px; border-left: 3px solid #00ffcc; font-size: 10px; text-transform: uppercase; letter-spacing: 2px; }
    </style>
</head>
<body>

<div class="container">
    <div class="canvas-container">
        <div class="status-bar">Source_Capture</div>
        <video id="webcam"></video>
        <canvas id="canvas_input"></canvas>
    </div>
    <div class="canvas-container">
        <div class="status-bar">Neural_Mesh_Output_v4</div>
        <canvas id="canvas_mesh"></canvas>
    </div>
</div>

<script type="module">
    const videoElement = document.getElementById('webcam');
    const canvasIn = document.getElementById('canvas_input');
    const canvasMesh = document.getElementById('canvas_mesh');
    const ctxIn = canvasIn.getContext('2d');
    const ctxMesh = canvasMesh.getContext('2d');

    // Función avanzada para crear "tejido" de malla en el cuerpo
    function drawPrecisionBody(ctx, landmarks, w, h) {
        const lm = landmarks;
        ctx.strokeStyle = "rgba(0, 255, 255, 0.5)";
        ctx.lineWidth = 0.8;

        const getPt = (idx) => lm[idx] ? { x: lm[idx].x * w, y: lm[idx].y * h } : null;

        const drawNetwork = (p1, p2, p3, p4) => {
            const pts = [getPt(p1), getPt(p2), getPt(p3), getPt(p4)].filter(p => p);
            if (pts.length < 3) return;
            
            ctx.beginPath();
            ctx.moveTo(pts[0].x, pts[0].y);
            for(let i=1; i<pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
            ctx.closePath();
            ctx.stroke();

            // Líneas de subdivisión interna (El "secreto" del volumen)
            if (pts.length === 4) {
                ctx.beginPath();
                ctx.moveTo(pts[0].x, pts[0].y); ctx.lineTo(pts[2].x, pts[2].y);
                ctx.moveTo(pts[1].x, pts[1].y); ctx.lineTo(pts[3].x, pts[3].y);
                ctx.strokeStyle = "rgba(0, 255, 255, 0.15)";
                ctx.stroke();
            }
        };

        // Torso Triangulado
        drawNetwork(11, 12, 24, 23);
        // Brazos con doble línea de volumen
        drawNetwork(11, 13, 15); // Izquierdo
        drawNetwork(12, 14, 16); // Derecho
        
        // Conexión Cuello-Hombros
        const nose = getPt(0);
        const lS = getPt(11);
        const rS = getPt(12);
        if(nose && lS && rS) {
            ctx.beginPath();
            ctx.moveTo(nose.x, nose.y); ctx.lineTo(lS.x, lS.y);
            ctx.lineTo(rS.x, rS.y); ctx.closePath();
            ctx.stroke();
        }
    }

    function onResults(results) {
        canvasIn.width = canvasMesh.width = videoElement.videoWidth;
        canvasIn.height = canvasMesh.height = videoElement.videoHeight;

        // Limpieza y fondo
        ctxIn.drawImage(results.image, 0, 0, canvasIn.width, canvasIn.height);
        ctxMesh.fillStyle = "#000";
        ctxMesh.fillRect(0, 0, canvasMesh.width, canvasMesh.height);

        ctxMesh.save();
        ctxMesh.shadowBlur = 8;
        ctxMesh.shadowColor = "#00FFFF";

        // 1. CARA: MALLA PURA SIN OVERLAY
        if (results.faceLandmarks) {
            // Dibujamos el tessellation con transparencia para que no sature
            drawConnectors(ctxMesh, results.faceLandmarks, FACEMESH_TESSELATION, {
                color: "rgba(0, 255, 255, 0.3)", 
                lineWidth: 0.5
            });
            // Definimos el óvalo facial pero muy sutil
            drawConnectors(ctxMesh, results.faceLandmarks, FACEMESH_FACE_OVAL, {
                color: "rgba(0, 255, 255, 0.6)", 
                lineWidth: 0.8
            });
            // IMPORTANTE: Hemos omitido FACEMESH_LIPS y FACEMESH_EYES para no tener líneas dobles
        }

        // 2. CUERPO: ESTRUCTURA TÉCNICA
        if (results.poseLandmarks) {
            drawPrecisionBody(ctxMesh, results.poseLandmarks, canvasMesh.width, canvasMesh.height);
            // Conectores base para estabilidad visual
            drawConnectors(ctxMesh, results.poseLandmarks, POSE_CONNECTIONS, {
                color: "#00FFFF", 
                lineWidth: 1.2
            });
        }

        // 3. MANOS: WIREFRAME LIMPIO
        const handCfg = { color: "rgba(255, 255, 255, 0.5)", lineWidth: 1 };
        if (results.leftHandLandmarks) drawConnectors(ctxMesh, results.leftHandLandmarks, HAND_CONNECTIONS, handCfg);
        if (results.rightHandLandmarks) drawConnectors(ctxMesh, results.rightHandLandmarks, HAND_CONNECTIONS, handCfg);

        ctxMesh.restore();
    }

    const holistic = new Holistic({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`});
    holistic.setOptions({ 
        modelComplexity: 1, 
        smoothLandmarks: true, 
        refineFaceLandmarks: true, 
        minDetectionConfidence: 0.7, // Subimos confianza para evitar errores
        minTrackingConfidence: 0.7 
    });
    holistic.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => { await holistic.send({image: videoElement}); },
        width: 640, height: 480
    });
    camera.start();
</script>

</body>
</html>
