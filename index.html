<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Mocap Ultra-Persistente V7</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; font-family: 'Consolas', monospace; }
        #webcam { position: absolute; bottom: 20px; right: 20px; width: 260px; transform: scaleX(-1); border: 2px solid #00d2ff; border-radius: 10px; opacity: 0.8; }
        #debug { position: absolute; top: 20px; left: 20px; color: #00ffaa; background: rgba(0,0,0,0.9); padding: 15px; border-radius: 5px; border-left: 4px solid #00d2ff; pointer-events: none; }
    </style>
</head>
<body>
    <div id="debug">
        SISTEMA DE ANCLAJE BIOMECÁNICO<br>
        > MODO: PERSISTENCIA ACTIVA<br>
        > STATUS: <span id="sync">ESTABILIZANDO...</span>
    </div>
    <video id="webcam" autoplay playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const videoElement = document.getElementById('webcam');
        const syncLabel = document.getElementById('sync');

        // --- MOTOR RENDER ---
        const scene = new THREE.Scene();
        const camera3D = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const light = new THREE.PointLight(0xffffff, 1, 100);
        light.position.set(0, 5, 5);
        scene.add(light, new THREE.AmbientLight(0x404040, 2));

        // --- CONSTRUCCIÓN DEL ROBOT ANCLADO ---
        const matCuerpo = new THREE.MeshPhongMaterial({ color: 0x222222 });
        const matArtic = new THREE.MeshPhongMaterial({ color: 0x00d2ff, emissive: 0x00d2ff, emissiveIntensity: 0.4 });

        const torso = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.8, 0.2), matCuerpo);
        const cabeza = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.35, 0.25), matCuerpo);
        scene.add(torso, cabeza);

        function construirBrazo(lado) {
            const hombro = new THREE.Group();
            hombro.position.set(lado * 0.35, 0.35, 0);
            
            const superior = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.05, 0.45), matCuerpo);
            superior.position.y = -0.225;
            
            const codo = new THREE.Group();
            codo.position.y = -0.45;
            
            const inferior = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.04, 0.45), matCuerpo);
            inferior.position.y = -0.225;

            const mano = new THREE.Mesh(new THREE.SphereGeometry(0.07, 16, 16), matArtic);
            mano.position.y = -0.45;

            codo.add(inferior, mano);
            hombro.add(superior, codo);
            torso.add(hombro);

            return { hombro, codo, mano };
        }

        const brazoD = construirBrazo(-1);
        const brazoI = construirBrazo(1);
        camera3D.position.z = 4;

        // --- SISTEMA DE PERSISTENCIA (Para que no desaparezca) ---
        const buffer = {};
        const getSmooth = (id, target, vis) => {
            if (!buffer[id]) buffer[id] = { pos: new THREE.Vector3().copy(target), v: 0 };
            // Si la visibilidad es baja, reducimos la velocidad de movimiento pero NO lo borramos
            let factor = vis > 0.5 ? 0.2 : 0.02; 
            buffer[id].pos.lerp(target, factor);
            return buffer[id].pos;
        };

        const holistic = new Holistic({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`});
        holistic.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

        holistic.onResults((res) => {
            if (!res.poseLandmarks) {
                syncLabel.innerText = "BUSCANDO...";
                return;
            }
            syncLabel.innerText = "SINCRONIZADO";
            const p = res.poseLandmarks;

            const toV = (pt) => new THREE.Vector3((pt.x - 0.5) * -4, (pt.y - 0.5) * -4, pt.z * -2);

            // Torso y Cabeza persistentes
            const nPos = getSmooth('n', toV(p[0]), p[0].visibility);
            cabeza.position.set(nPos.x, nPos.y + 0.3, nPos.z);
            torso.position.set(nPos.x, nPos.y - 0.5, nPos.z);

            // Brazos Conectados (IK Simple)
            resolverBrazo(brazoD, toV(p[11]), toV(p[13]), toV(p[15]), p[15].visibility);
            resolverBrazo(brazoI, toV(p[12]), toV(p[14]), toV(p[16]), p[16].visibility);
        });

        function resolverBrazo(brazo, h, c, m, vis) {
            // Dirección Hombro -> Codo
            const dirSup = new THREE.Vector3().subVectors(c, h).normalize();
            brazo.hombro.quaternion.setFromUnitVectors(new THREE.Vector3(0, -1, 0), dirSup);

            // Dirección Codo -> Mano
            const dirInf = new THREE.Vector3().subVectors(m, c).normalize();
            const localInf = dirInf.clone().applyQuaternion(brazo.hombro.quaternion.clone().invert());
            brazo.codo.quaternion.setFromUnitVectors(new THREE.Vector3(0, -1, 0), localInf);
            
            // Efecto Visual: Si saludas o haces pulgar arriba, la mano brilla más
            brazo.mano.material.emissiveIntensity = vis > 0.8 ? 1.0 : 0.4;
        }

        const camera = new Camera(videoElement, {
            onFrame: async () => { await holistic.send({image: videoElement}); },
            width: 1280, height: 720
        });
        camera.start();

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera3D);
        }
        animate();
    </script>
</body>
</html>
