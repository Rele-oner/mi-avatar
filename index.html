<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>AI Avatar - V28 BERSERKER</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', monospace; }
        #ui { position: absolute; top: 20px; left: 20px; z-index: 10; border-left: 2px solid #00ffcc; padding-left: 15px; transition: color 0.3s; }
        canvas { width: 100vw; height: 100vh; transform: rotateY(180deg); }
        video { display: none; }
        .danger { color: #ff3300 !important; border-left-color: #ff3300 !important; }
    </style>
</head>
<body>
    <div id="ui">
        <div id="mode-text" style="font-size: 9px; opacity: 0.5;">LINK: NOMINAL</div>
        <div id="fps" style="font-size: 16px; font-weight: bold;">0 FPS</div>
    </div>
    <canvas id="out"></canvas>
    <video id="v" playsinline></video>

<script type="module">
    const video = document.getElementById('v');
    const canvas = document.getElementById('out');
    const ctx = canvas.getContext('2d');
    let particles = [];
    let lastTime = 0;
    let isBerserker = false;

    class Particle {
        constructor(x, y, color) {
            this.x = x; this.y = y;
            this.vx = (Math.random() - 0.5) * 15;
            this.vy = (Math.random() - 0.5) * 15;
            this.life = 1.0;
            this.color = color;
        }
        update() { this.x += this.vx; this.y += this.vy; this.life -= 0.03; }
        draw() {
            ctx.fillStyle = this.color.replace('1)', `${this.life})`);
            ctx.fillRect(this.x, this.y, 3, 3);
        }
    }

    function onResults(res) {
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        ctx.fillStyle = "#000"; ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (res.multiFaceLandmarks && res.multiFaceLandmarks.length > 0) {
            const face = res.multiFaceLandmarks[0];
            
            // LÓGICA DE DETECCIÓN: APERTURA DE BOCA
            const mouthTop = face[13].y; const mouthBottom = face[14].y;
            const mouthOpen = Math.abs(mouthTop - mouthBottom);
            isBerserker = mouthOpen > 0.05; // Umbral de "grito"

            const mainColor = isBerserker ? "rgba(255, 51, 0, 1)" : "rgba(0, 255, 204, 1)";
            const ui = document.getElementById('ui');
            ui.className = isBerserker ? 'danger' : '';
            document.getElementById('mode-text').innerText = isBerserker ? "WARNING: OVERLOAD" : "LINK: NOMINAL";

            // Efecto Shake en modo Berserker
            if(isBerserker) ctx.translate((Math.random()-0.5)*10, (Math.random()-0.5)*10);

            // Dibujar Rostro
            ctx.shadowBlur = isBerserker ? 25 : 15;
            ctx.shadowColor = isBerserker ? "#ff3300" : "#00ffcc";
            ctx.strokeStyle = mainColor;
            ctx.lineWidth = isBerserker ? 4 : 2;
            
            ctx.beginPath();
            [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109].forEach((idx, i) => {
                const p = face[idx]; i === 0 ? ctx.moveTo(p.x*canvas.width, p.y*canvas.height) : ctx.lineTo(p.x*canvas.width, p.y*canvas.height);
            });
            ctx.closePath(); ctx.stroke();

            // Ojos (Iris)
            ctx.fillStyle = "#fff";
            [468, 473].forEach(idx => {
                const p = face[idx]; ctx.beginPath(); ctx.arc(p.x*canvas.width, p.y*canvas.height, 6, 0, 7); ctx.fill();
                if(isBerserker) for(let i=0; i<2; i++) particles.push(new Particle(p.x*canvas.width, p.y*canvas.height, mainColor));
            });
        }

        particles = particles.filter(p => p.life > 0);
        particles.forEach(p => { p.update(); p.draw(); });

        const now = performance.now();
        document.getElementById('fps').innerText = Math.round(1000 / (now - lastTime)) + " FPS";
        lastTime = now;
    }

    const faceMesh = new FaceMesh({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
    faceMesh.setOptions({maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.6});
    faceMesh.onResults(onResults);
    new Camera(video, {onFrame: async () => {await faceMesh.send({image: video})}, width: 640, height: 480}).start();
</script>
</body>
</html>
