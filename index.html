<!DOCTYPE html>
<html>
<head>
    <title>Rotoscopia Maestra - Captura Directa</title>
    <style>
        body { margin: 0; background-color: #00ff00; overflow: hidden; }
        #webcam { position: absolute; bottom: 10px; right: 10px; width: 220px; transform: scaleX(-1); border: 2px solid white; border-radius: 10px; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        #status { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.8); padding: 15px; font-family: sans-serif; border-radius: 8px; border-left: 5px solid #00ff00; }
    </style>
</head>
<body>
    <div id="status">
        <b>SISTEMA DE ROTOSCOPIA</b><br>
        Estado: <span id="info">Sincronizando...</span><br>
        <small>Asegúrate de que se vean tus codos</small>
    </div>
    <video id="webcam" autoplay playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const videoElement = document.getElementById('webcam');
        const info = document.getElementById('info');

        const scene = new THREE.Scene();
        const camera3D = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const material = new THREE.MeshNormalMaterial();
        
        // Elementos del cuerpo independientes para máxima libertad de movimiento
        const cabeza = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.45, 0.3), material);
        const tronco = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.8, 0.2), material);
        
        // Brazos segmentados
        const crearParte = () => new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1), material);
        const bDerSup = crearParte(); const bDerInf = crearParte();
        const bIzqSup = crearParte(); const bIzqInf = crearParte();

        scene.add(cabeza, tronco, bDerSup, bDerInf, bIzqSup, bIzqInf);
        camera3D.position.z = 4;

        const holistic = new Holistic({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`});
        holistic.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

        holistic.onResults((res) => {
            if (!res.poseLandmarks) {
                info.innerText = "BUSCANDO SILUETA...";
                return;
            }
            info.innerText = "SINCRONIZACIÓN PERFECTA";
            const p = res.poseLandmarks;

            // Función para convertir coordenadas de MediaPipe a Three.js
            const map = (point) => ({
                x: (point.x - 0.5) * -4,
                y: (point.y - 0.5) * -4,
                z: point.z * -2
            });

            // 1. Cabeza y Tronco
            const n = map(p[0]); // Nariz
            cabeza.position.set(n.x, n.y + 0.3, n.z);
            
            const hDer = map(p[11]); const hIzq = map(p[12]);
            tronco.position.set((hDer.x + hIzq.x)/2, (hDer.y + hIzq.y)/2 - 0.4, (hDer.z + hIzq.z)/2);

            // 2. BRAZO DERECHO (Hombro -> Codo -> Muñeca)
            const cDer = map(p[13]); const mDer = map(p[15]);
            actualizarHueso(bDerSup, hDer, cDer);
            actualizarHueso(bDerInf, cDer, mDer);

            // 3. BRAZO IZQUIERDO (Hombro -> Codo -> Muñeca)
            const cIzq = map(p[14]); const mIzq = map(p[16]);
            actualizarHueso(bIzqSup, hIzq, cIzq);
            actualizarHueso(bIzqInf, cIzq, mIzq);
        });

        function actualizarHueso(malla, inicio, fin) {
            const startV = new THREE.Vector3(inicio.x, inicio.y, inicio.z);
            const endV = new THREE.Vector3(fin.x, fin.y, fin.z);
            const dir = new THREE.Vector3().subVectors(endV, startV);
            const len = dir.length();
            
            malla.scale.y = len; // Ajusta el largo del cilindro a tu brazo real
            malla.position.copy(startV).add(dir.multiplyScalar(0.5));
            malla.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir.clone().normalize());
        }

        const camera = new Camera(videoElement, {
            onFrame: async () => { await holistic.send({image: videoElement}); },
            width: 1280, height: 720
        });
        camera.start();

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera3D);
        }
        animate();
    </script>
</body>
</html>
