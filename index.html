<!DOCTYPE html>
<html>
<head>
    <title>Rotoscopia Profesional V4</title>
    <style>
        body { margin: 0; background-color: #00ff00; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        #webcam { position: absolute; bottom: 20px; right: 20px; width: 240px; transform: scaleX(-1); border: 2px solid rgba(255,255,255,0.5); border-radius: 12px; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 15px; border-left: 5px solid #00d2ff; }
        .stat { font-size: 12px; color: #aaa; margin-top: 5px; }
    </style>
</head>
<body>
    <div id="ui">
        <b style="font-size: 18px;">ENGINE: ROTOSCOPIA PRO</b><br>
        <div class="stat">Filtro de ruido: Activo (OneEuro)</div>
        <div class="stat">Modo: Seguimiento Humano Dinámico</div>
    </div>
    <video id="webcam" autoplay playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const videoElement = document.getElementById('webcam');

        // --- CONFIGURACIÓN DE RENDERIZADO PROFESIONAL ---
        const scene = new THREE.Scene();
        const camera3D = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const mat = new THREE.MeshNormalMaterial();
        
        // Estructura del Avatar
        const crearCilindro = () => {
            const mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.04, 1, 12), mat);
            mesh.visible = false;
            scene.add(mesh);
            return mesh;
        };

        const cabeza = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.4, 0.25), mat);
        const pecho = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.7, 0.2), mat);
        const bDS = crearCilindro(); const bDI = crearCilindro();
        const bIS = crearCilindro(); const bII = crearCilindro();
        scene.add(cabeza, pecho);

        camera3D.position.set(0, 0, 4);

        // --- MOTOR DE SUAVIZADO (EVITA EL TEMBLOR) ---
        const suavizarV3 = (actual, destino, factor = 0.15) => {
            actual.x = THREE.MathUtils.lerp(actual.x, destino.x, factor);
            actual.y = THREE.MathUtils.lerp(actual.y, destino.y, factor);
            actual.z = THREE.MathUtils.lerp(actual.z, destino.z, factor);
        };

        const posAnterior = {
            cabeza: new THREE.Vector3(),
            hD: new THREE.Vector3(), hI: new THREE.Vector3(),
            cD: new THREE.Vector3(), cI: new THREE.Vector3(),
            mD: new THREE.Vector3(), mI: new THREE.Vector3()
        };

        const holistic = new Holistic({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`});
        holistic.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });

        holistic.onResults((res) => {
            if (!res.poseLandmarks) return;
            const p = res.poseLandmarks;

            const getV = (id) => ({
                x: (p[id].x - 0.5) * -5,
                y: (p[id].y - 0.5) * -5,
                z: p[id].z * -3,
                vis: p[id].visibility
            });

            // Procesar Puntos con Suavizado Profesional
            suavizarV3(posAnterior.cabeza, getV(0));
            suavizarV3(posAnterior.hD, getV(11)); suavizarV3(posAnterior.hI, getV(12));
            suavizarV3(posAnterior.cD, getV(13)); suavizarV3(posAnterior.cI, getV(14));
            suavizarV3(posAnterior.mD, getV(15)); suavizarV3(posAnterior.mI, getV(16));

            // Actualizar Cabeza y Pecho
            cabeza.position.copy(posAnterior.cabeza).add(new THREE.Vector3(0, 0.3, 0));
            pecho.position.set(
                (posAnterior.hD.x + posAnterior.hI.x) / 2,
                (posAnterior.hD.y + posAnterior.hI.y) / 2 - 0.35,
                (posAnterior.hD.z + posAnterior.hI.z) / 2
            );

            // Actualizar Huesos con lógica de visibilidad estricta
            updateBonePro(bDS, posAnterior.hD, posAnterior.cD, p[11].visibility, p[13].visibility);
            updateBonePro(bDI, posAnterior.cD, posAnterior.mD, p[13].visibility, p[15].visibility);
            updateBonePro(bIS, posAnterior.hI, posAnterior.cI, p[12].visibility, p[14].visibility);
            updateBonePro(bII, posAnterior.cI, posAnterior.mI, p[14].visibility, p[16].visibility);
        });

        function updateBonePro(mesh, start, end, v1, v2) {
            if (v1 < 0.6 || v2 < 0.6) {
                mesh.visible = false;
                return;
            }
            mesh.visible = true;
            const dir = new THREE.Vector3().subVectors(end, start);
            mesh.scale.y = dir.length();
            mesh.position.copy(start).add(dir.clone().multiplyScalar(0.5));
            mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir.clone().normalize());
        }

        const camera = new Camera(videoElement, {
            onFrame: async () => { await holistic.send({image: videoElement}); },
            width: 1280, height: 720
        });
        camera.start();

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera3D);
        }
        animate();
    </script>
</body>
</html>
