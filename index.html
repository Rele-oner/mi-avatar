<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>AI Avatar - V29 Neural Overload</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', monospace; }
        #ui { position: absolute; top: 25px; left: 25px; color: #00ffcc; z-index: 10; border-left: 3px solid #00ffcc; padding-left: 20px; text-shadow: 0 0 10px #00ffcc; }
        canvas { width: 100vw; height: 100vh; transform: rotateY(180deg); }
        video { display: none; }
        .label { font-size: 10px; opacity: 0.6; letter-spacing: 3px; }
        .val { font-size: 18px; font-weight: bold; }
    </style>
</head>
<body>
    <div id="ui">
        <div class="label">NEURAL_DENSITY</div>
        <div class="val">HIGH_RES_v29</div>
        <div id="fps" style="font-size: 12px; margin-top:5px;">0 FPS</div>
    </div>
    <canvas id="out"></canvas>
    <video id="v" playsinline></video>

<script type="module">
    const video = document.getElementById('v');
    const canvas = document.getElementById('out');
    const ctx = canvas.getContext('2d');
    let lastTime = 0;
    let scanLineY = 0;

    function onResults(res) {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Fondo: Grid de datos con perspectiva
        ctx.strokeStyle = "rgba(0, 255, 204, 0.05)";
        for(let i=0; i<canvas.width; i+=40) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); ctx.stroke(); }

        if (res.multiFaceLandmarks && res.multiFaceLandmarks.length > 0) {
            const face = res.multiFaceLandmarks[0];

            // 1. MALLA COMPLETA (Efecto Complejidad)
            // Usamos la tesselación pero con una línea ultra-fina
            ctx.lineWidth = 0.5;
            ctx.strokeStyle = "rgba(0, 255, 204, 0.15)";
            drawConnectors(ctx, face, FACEMESH_TESSELATION, {color: 'rgba(0, 255, 204, 0.2)', lineWidth: 0.5});

            // 2. CONTORNOS PRINCIPALES (Efecto HUD)
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#00ffcc";
            ctx.shadowBlur = 15;
            ctx.shadowColor = "#00ffcc";
            drawConnectors(ctx, face, FACEMESH_FACE_OVAL, {color: '#00ffcc', lineWidth: 2});
            drawConnectors(ctx, face, FACEMESH_LIPS, {color: '#fff', lineWidth: 1});

            // 3. IRIS PROTOCOL (Ojos Divinos)
            ctx.fillStyle = "#fff";
            [468, 473].forEach(idx => {
                const p = face[idx];
                ctx.beginPath();
                ctx.arc(p.x * canvas.width, p.y * canvas.height, 6, 0, Math.PI * 2);
                ctx.fill();
                // Brillo extra en ojos
                ctx.shadowBlur = 25;
                ctx.stroke();
            });

            // 4. EFECTO DE ESCANEO (Línea de datos que recorre la cara)
            scanLineY = (scanLineY + 5) % canvas.height;
            ctx.fillStyle = "rgba(0, 255, 204, 0.1)";
            ctx.fillRect(0, scanLineY, canvas.width, 2);
        }

        const now = performance.now();
        document.getElementById('fps').innerText = Math.round(1000 / (now - lastTime)) + " FPS";
        lastTime = now;
    }

    const faceMesh = new FaceMesh({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
    });

    faceMesh.setOptions({
        maxNumFaces: 1,
        refineLandmarks: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    faceMesh.onResults(onResults);

    const camera = new Camera(video, {
        onFrame: async () => { await faceMesh.send({image: video}); },
        width: 1280, height: 720
    });
    camera.start();
</script>
</body>
</html>
