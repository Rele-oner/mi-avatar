<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Motor de Rotoscopia Ultra-Preciso V6</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #webcam { position: absolute; bottom: 20px; right: 20px; width: 280px; transform: scaleX(-1); border: 2px solid #00d2ff; border-radius: 15px; box-shadow: 0 0 20px rgba(0, 210, 255, 0.5); z-index: 10; }
        #ui-panel { position: absolute; top: 20px; left: 20px; color: #00d2ff; background: rgba(10, 10, 10, 0.9); padding: 25px; border-radius: 15px; border: 1px solid #00d2ff; pointer-events: none; min-width: 250px; }
        .data-stream { font-family: 'Consolas', monospace; font-size: 11px; color: #00ffaa; margin-top: 10px; }
        .grid-bg { position: fixed; width: 100vw; height: 100vh; background-image: linear-gradient(rgba(0,210,255,0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(0,210,255,0.1) 1px, transparent 1px); background-size: 50px 50px; z-index: -1; }
    </style>
</head>
<body>
    <div class="grid-bg"></div>
    <div id="ui-panel">
        <b style="font-size: 20px; letter-spacing: 2px;">PRECISION MOCAP ENGINE</b><br>
        <div style="height: 2px; background: #00d2ff; margin: 10px 0;"></div>
        <div class="data-stream" id="stats">Sincronizando sensores...</div>
    </div>
    <video id="webcam" autoplay playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const videoElement = document.getElementById('webcam');
        const statsDisplay = document.getElementById('stats');

        // --- RENDERER DE GRADO INDUSTRIAL ---
        const scene = new THREE.Scene();
        const camera3D = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const material = new THREE.MeshPhongMaterial({ color: 0x00d2ff, wireframe: false, flatShading: false });
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(1, 1, 2).normalize();
        scene.add(light, new THREE.AmbientLight(0x404040));

        // --- CONSTRUCCIÓN DEL ESQUELETO METICULOSO ---
        const skeleton = {
            cabeza: new THREE.Mesh(new THREE.SphereGeometry(0.22, 32, 32), material),
            tronco: new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.7, 0.2), material),
            brazos: {
                der: { sup: crearCilindro(0.05), inf: crearCilindro(0.04) },
                izq: { sup: crearCilindro(0.05), inf: crearCilindro(0.04) }
            },
            manos: {
                der: crearEstructuraMano(),
                izq: crearEstructuraMano()
            }
        };

        function crearCilindro(radio) {
            const mesh = new THREE.Mesh(new THREE.CylinderGeometry(radio, radio * 0.8, 1, 16), material);
            mesh.visible = false;
            scene.add(mesh);
            return mesh;
        }

        function crearEstructuraMano() {
            // Creamos 21 esferas para representar cada articulación de la mano
            return Array.from({ length: 21 }, () => {
                const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.015, 8, 8), material);
                sphere.visible = false;
                scene.add(sphere);
                return sphere;
            });
        }

        scene.add(skeleton.cabeza, skeleton.tronco);
        camera3D.position.set(0, 0, 4);

        // --- FILTRADO DE DATOS AVANZADO (Exponential Smoothing) ---
        const smoothingFactor = 0.2; 
        const history = {};

        function filter(id, vec) {
            if (!history[id]) history[id] = new THREE.Vector3().copy(vec);
            history[id].lerp(vec, smoothingFactor);
            return history[id];
        }

        // --- LÓGICA DE PROCESAMIENTO ---
        const holistic = new Holistic({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`});
        holistic.setOptions({
            modelComplexity: 2, // MÁXIMA PRECISIÓN
            smoothLandmarks: true,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        holistic.onResults((res) => {
            if (!res.poseLandmarks) {
                statsDisplay.innerHTML = "ESTADO: BUSCANDO SUJETO...";
                return;
            }

            statsDisplay.innerHTML = `LATENCIA: ${Math.round(performance.now() % 100)}ms<br>RESOLUCIÓN: 1280x720<br>TRACKING: 3D FULL BODY`;

            const p = res.poseLandmarks;
            const toV = (pt) => new THREE.Vector3((pt.x - 0.5) * -4, (pt.y - 0.5) * -4, pt.z * -3);

            // Filtrado de puntos clave
            const hD = filter('hD', toV(p[11])), hI = filter('hI', toV(p[12]));
            const cD = filter('cD', toV(p[13])), cI = filter('cI', toV(p[14]));
            const mD = filter('mD', toV(p[15])), mI = filter('mI', toV(p[16]));

            // 1. Cabeza y Tronco
            const nariz = filter('n', toV(p[0]));
            skeleton.cabeza.position.copy(nariz).add(new THREE.Vector3(0, 0.2, 0));
            skeleton.tronco.position.set((hD.x + hI.x)/2, (hD.y + hI.y)/2 - 0.35, (hD.z + hI.z)/2);
            skeleton.tronco.lookAt(hI.x, (hD.y + hI.y)/2 - 0.35, hI.z); // Orientación del pecho

            // 2. Brazos
            updateBone(skeleton.brazos.der.sup, hD, cD, p[11].visibility, p[13].visibility);
            updateBone(skeleton.brazos.der.inf, cD, mD, p[13].visibility, p[15].visibility);
            updateBone(skeleton.brazos.izq.sup, hI, cI, p[12].visibility, p[14].visibility);
            updateBone(skeleton.brazos.izq.inf, cI, mI, p[14].visibility, p[16].visibility);

            // 3. Manos (Seguimiento de 21 puntos por mano)
            updateHand(res.rightHandLandmarks, skeleton.manos.der, mD);
            updateHand(res.leftHandLandmarks, skeleton.manos.izq, mI);
        });

        function updateBone(mesh, start, end, v1, v2) {
            if (v1 < 0.6 || v2 < 0.6) { mesh.visible = false; return; }
            mesh.visible = true;
            const dir = new THREE.Vector3().subVectors(end, start);
            mesh.scale.y = dir.length();
            mesh.position.copy(start).add(dir.clone().multiplyScalar(0.5));
            mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir.clone().normalize());
        }

        function updateHand(handPts, meshes, wristRef) {
            if (!handPts) { meshes.forEach(m => m.visible = false); return; }
            handPts.forEach((pt, i) => {
                meshes[i].visible = true;
                // Posición absoluta mitigando la deriva de profundidad
                meshes[i].position.set((pt.x - 0.5) * -4, (pt.y - 0.5) * -4, pt.z * -3);
            });
        }

        const camera = new Camera(videoElement, {
            onFrame: async () => { await holistic.send({image: videoElement}); },
            width: 1280, height: 720
        });
        camera.start();

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera3D);
        }
        animate();

        window.addEventListener('resize', () => {
            camera3D.aspect = window.innerWidth / window.innerHeight;
            camera3D.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
