<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>ULTRA-FAST MOCAP ENGINE V10</title>
    <style>
        body { margin: 0; background-color: #00ff00; overflow: hidden; }
        #webcam { position: absolute; bottom: 10px; right: 10px; width: 180px; transform: scaleX(-1); border-radius: 5px; opacity: 0.5; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.8); padding: 10px; font-family: monospace; border-left: 3px solid #00d2ff; }
    </style>
</head>
<body>
    <div id="ui">LATENCIA: <span id="ms">0</span>ms | STATUS: OK</div>
    <video id="webcam" autoplay playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x00ff00);
        const camera3D = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 100);
        camera3D.position.set(0, 0, 4);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1.2);
        light.position.set(0, 10, 10);
        scene.add(light, new THREE.AmbientLight(0xffffff, 0.4));

        // --- RIGGING MECÁNICO (OPTIMIZADO) ---
        const mat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8, roughness: 0.2 });
        const matG = new THREE.MeshStandardMaterial({ color: 0x00d2ff, emissive: 0x00d2ff });

        const root = new THREE.Group();
        const torso = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.8, 0.25), mat);
        const cabeza = new THREE.Mesh(new THREE.BoxGeometry(0.28, 0.35, 0.22), mat);
        cabeza.position.y = 0.6;
        root.add(torso, cabeza);
        scene.add(root);

        function addLimb(side) {
            const h = new THREE.Group();
            h.position.set(side * 0.35, 0.35, 0);
            const s = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.45), mat);
            s.position.y = -0.225;
            const c = new THREE.Group();
            c.position.y = -0.45;
            const i = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.04, 0.45), mat);
            i.position.y = -0.225;
            const m = new THREE.Mesh(new THREE.SphereGeometry(0.07), matG);
            m.position.y = -0.45;
            c.add(i, m); h.add(s, c); torso.add(h);
            return { h, c };
        }
        const bD = addLimb(-1); const bI = addLimb(1);

        // --- FILTRADO DE PREDICCIÓN ---
        const smoothing = 0.12; 
        const state = {};
        function fastLerp(id, target) {
            if (!state[id]) state[id] = new THREE.Vector3().copy(target);
            state[id].lerp(target, smoothing);
            return state[id];
        }

        const holistic = new Holistic({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`});
        holistic.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.6 });

        holistic.onResults((res) => {
            const t0 = performance.now();
            if (!res.poseLandmarks) return;
            const p = res.poseLandmarks;

            const toV = (pt) => new THREE.Vector3((pt.x - 0.5) * -3.5, (pt.y - 0.5) * -3.5, 0);

            // Mover base
            const neck = fastLerp('neck', toV(p[0]));
            root.position.set(neck.x, neck.y - 0.2, 0);

            // Rotación de Cabeza simplificada
            if(res.faceLandmarks) {
                const f = res.faceLandmarks;
                const top = new THREE.Vector3(f[10].x, f[10].y, f[10].z);
                const bot = new THREE.Vector3(f[152].x, f[152].y, f[152].z);
                const look = new THREE.Vector3().subVectors(top, bot).normalize();
                cabeza.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), look);
            }

            // Brazos: Cinemática Inversa Veloz
            updateL(bD, toV(p[11]), toV(p[13]), toV(p[15]));
            updateL(bI, toV(p[12]), toV(p[14]), toV(p[16]));
            
            document.getElementById('ms').innerText = Math.round(performance.now() - t0);
        });

        function updateL(limb, h, c, m) {
            const d1 = new THREE.Vector3().subVectors(c, h).normalize();
            limb.h.quaternion.setFromUnitVectors(new THREE.Vector3(0, -1, 0), d1);
            const d2 = new THREE.Vector3().subVectors(m, c).normalize();
            const loc = d2.applyQuaternion(limb.h.quaternion.clone().invert());
            limb.c.quaternion.setFromUnitVectors(new THREE.Vector3(0, -1, 0), loc);
        }

        const camera = new Camera(document.getElementById('webcam'), {
            onFrame: async () => { await holistic.send({image: document.getElementById('webcam')}); },
            width: 1280, height: 720
        });
        camera.start();

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera3D);
        }
        animate();
    </script>
</body>
</html>
