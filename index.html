<!DOCTYPE html>
<html>
<head>
    <title>Avatar Pro - PrecisiÃ³n Extrema</title>
    <style>
        body { margin: 0; background-color: #00ff00; overflow: hidden; }
        #webcam { position: absolute; bottom: 10px; right: 10px; width: 160px; transform: scaleX(-1); border: 2px solid #00a8ff; border-radius: 5px; opacity: 0.6; }
        #ui-container { position: absolute; top: 10px; left: 10px; display: flex; flex-direction: column; gap: 8px; z-index: 100; }
        .btn-reset { padding: 12px 20px; background: #00a8ff; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; font-family: sans-serif; }
        #status { color: white; background: rgba(0,0,0,0.8); padding: 10px; font-family: sans-serif; border-radius: 8px; border-left: 4px solid #00ff00; font-size: 13px; }
    </style>
</head>
<body>
    <div id="ui-container">
        <div id="status">Buscando Pose-T...</div>
        <button class="btn-reset" onclick="location.reload()">ðŸ”„ RECALIBRAR SISTEMA</button>
    </div>
    <video id="webcam" autoplay playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const videoElement = document.getElementById('webcam');
        const status = document.getElementById('status');

        const scene = new THREE.Scene();
        const camera3D = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const mat = new THREE.MeshNormalMaterial();
        const avatar = new THREE.Group();
        
        // --- ESTRUCTURA ANATÃ“MICA ---
        const cabeza = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.4, 0.25), mat);
        avatar.add(cabeza);

        const tronco = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.7, 0.2), mat);
        tronco.position.y = -0.6;
        avatar.add(tronco);

        function crearBrazoPro() {
            const hombro = new THREE.Group();
            const superior = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.035, 0.4), mat);
            superior.geometry.translate(0, -0.2, 0);
            
            const codo = new THREE.Group();
            codo.position.y = -0.4;
            const inferior = new THREE.Mesh(new THREE.CylinderGeometry(0.035, 0.03, 0.4), mat);
            inferior.geometry.translate(0, -0.2, 0);
            
            const mano = new THREE.Group();
            mano.position.y = -0.4;
            
            codo.add(inferior, mano);
            hombro.add(superior, codo);
            
            // 5 esferas para dedos
            const dedos = [];
            for(let i=0; i<5; i++) {
                const d = new THREE.Mesh(new THREE.SphereGeometry(0.02), mat);
                mano.add(d);
                dedos.push(d);
            }
            return { hombro, codo, mano, dedos };
        }

        const bDer = crearBrazoPro(); bDer.hombro.position.set(-0.3, -0.3, 0);
        const bIzq = crearBrazoPro(); bIzq.hombro.position.set(0.3, -0.3, 0);
        avatar.add(bDer.hombro, bIzq.hombro);

        scene.add(avatar);
        camera3D.position.set(0, -0.5, 2.8);

        // --- TRACKING DE ALTA FIDELIDAD ---
        const holistic = new Holistic({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`});
        holistic.setOptions({
            modelComplexity: 2, // MÃXIMA PRECISIÃ“N
            smoothLandmarks: true,
            minDetectionConfidence: 0.65,
            minTrackingConfidence: 0.65
        });

        holistic.onResults((res) => {
            // Rostro
            if (res.faceLandmarks) {
                status.innerText = "SISTEMA: OK - TRACKING ACTIVO";
                const n = res.faceLandmarks[1];
                cabeza.rotation.y = THREE.MathUtils.lerp(cabeza.rotation.y, (n.x - 0.5) * -1.5, 0.2);
                cabeza.rotation.x = THREE.MathUtils.lerp(cabeza.rotation.x, (n.y - 0.5) * 1.5, 0.2);
            }

            // Pose y Brazos (Filtro de visibilidad)
            if (res.poseLandmarks) {
                // Brazo Derecho (del personaje)
                if (res.poseLandmarks[11].visibility > 0.6 && res.poseLandmarks[13].visibility > 0.6) {
                    actualizarHuesos(res.poseLandmarks[11], res.poseLandmarks[13], res.poseLandmarks[15], bDer, -1);
                } else {
                    relajarBrazo(bDer);
                }

                // Brazo Izquierdo (del personaje)
                if (res.poseLandmarks[12].visibility > 0.6 && res.poseLandmarks[14].visibility > 0.6) {
                    actualizarHuesos(res.poseLandmarks[12], res.poseLandmarks[14], res.poseLandmarks[16], bIzq, 1);
                } else {
                    relajarBrazo(bIzq);
                }
            }

            // Manos ultra-detalladas
            if (res.rightHandLandmarks) actualizarDedos(res.rightHandLandmarks, bDer.dedos);
            if (res.leftHandLandmarks) actualizarDedos(res.leftHandLandmarks, bIzq.dedos);
        });

        function actualizarHuesos(h, c, m, miembro, lado) {
            const angH = Math.atan2(c.y - h.y, (c.x - h.x) * lado) + Math.PI/2;
            miembro.hombro.rotation.z = THREE.MathUtils.lerp(miembro.hombro.rotation.z, angH * lado, 0.3);
            
            const angC = Math.atan2(m.y - c.y, (m.x - c.x) * lado) - angH + Math.PI/2;
            miembro.codo.rotation.z = THREE.MathUtils.lerp(miembro.codo.rotation.z, angC * lado, 0.3);
        }

        function relajarBrazo(miembro) {
            miembro.hombro.rotation.z = THREE.MathUtils.lerp(miembro.hombro.rotation.z, 0, 0.1);
            miembro.codo.rotation.z = THREE.MathUtils.lerp(miembro.codo.rotation.z, 0, 0.1);
        }

        function actualizarDedos(puntos, esferas) {
            const base = puntos[0];
            [4, 8, 12, 16, 20].forEach((id, i) => {
                esferas[i].position.x = (puntos[id].x - base.x) * -2.5;
                esferas[i].position.y = (puntos[id].y - base.y) * -2.5;
                esferas[i].position.z = (puntos[id].z - base.z) * 2.5;
            });
        }

        const camera = new Camera(videoElement, {
            onFrame: async () => { await holistic.send({image: videoElement}); },
            width: 1280, height: 720
        });
        camera.start();

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera3D);
        }
        animate();
    </script>
</body>
</html>
