<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Avatar Mirror - 3D Skeleton Fix</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        body { 
            font-family: 'Courier New', Courier, monospace; 
            background: #050505; color: #00ffcc; margin: 0; 
            display: flex; flex-direction: column; align-items: center; 
        }
        .header { padding: 15px; text-align: center; width: 100%; border-bottom: 1px solid #333; }
        .main-view { 
            display: flex; justify-content: space-around; align-items: center; 
            width: 95vw; height: 75vh; margin-top: 20px; gap: 20px;
        }
        .view-box {
            position: relative; flex: 1; background: #111; 
            border: 2px solid #333; border-radius: 10px; overflow: hidden;
            height: 100%; display: flex; justify-content: center; align-items: center;
        }
        video { display: none; }
        canvas { max-width: 100%; max-height: 100%; }
        #canvas_capture { transform: rotateY(180deg); }
        .label {
            position: absolute; top: 10px; left: 10px; 
            background: rgba(0, 255, 204, 0.2); padding: 5px 10px; 
            border-radius: 5px; font-size: 12px; z-index: 5;
        }
        .loading-overlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: #000; display: flex; flex-direction: column; 
            justify-content: center; align-items: center; z-index: 100; 
        }
    </style>
</head>
<body>

    <div id="loader" class="loading-overlay">
        <h1>RECALIBRANDO MOTOR 3D...</h1>
        <p>Ajustando escalas y esqueleto</p>
    </div>

    <div class="header">
        <h2>SISTEMA DE DUPLICACIÓN DE MOVIMIENTO 3D v2.0</h2>
    </div>

    <div class="main-view">
        <div class="view-box">
            <div class="label">CAPTURA REAL</div>
            <video id="webcam"></video>
            <canvas id="canvas_capture"></canvas>
        </div>
        <div class="view-box" id="container_3d">
            <div class="label">AVATAR 3D RECALIBRADO</div>
        </div>
    </div>

    <script type="module">
        const videoElement = document.getElementById('webcam');
        const canvasCapture = document.getElementById('canvas_capture');
        const ctxCap = canvasCapture.getContext('2d');
        const loader = document.getElementById('loader');
        const container3d = document.getElementById('container_3d');

        // --- MOTOR THREE.JS ---
        const scene = new THREE.Scene();
        const camera3d = new THREE.PerspectiveCamera(50, container3d.clientWidth / container3d.clientHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container3d.clientWidth, container3d.clientHeight);
        container3d.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const directionalLight = new THREE.DirectionalLight(0x00ffcc, 1);
        directionalLight.position.set(0, 1, 5);
        scene.add(directionalLight);

        // Nodos y Esqueleto
        const points3d = [];
        const sphereGeo = new THREE.SphereGeometry(0.02, 16, 16);
        const mat = new THREE.MeshPhongMaterial({ color: 0x00ffcc });

        for (let i = 0; i < 33; i++) {
            const sphere = new THREE.Mesh(sphereGeo, mat);
            scene.add(sphere);
            points3d.push(sphere);
        }

        // Líneas para conectar los puntos (Esqueleto)
        const lineMat = new THREE.LineBasicMaterial({ color: 0xffffff });
        const lineGroup = new THREE.Group();
        scene.add(lineGroup);

        camera3d.position.set(0, 0, 3); // Alejamos la cámara para ver todo el cuerpo

        function onResults(results) {
            loader.style.display = "none";
            canvasCapture.width = videoElement.videoWidth;
            canvasCapture.height = videoElement.videoHeight;

            // 2D Draw
            ctxCap.save();
            ctxCap.clearRect(0, 0, canvasCapture.width, canvasCapture.height);
            ctxCap.drawImage(results.image, 0, 0, canvasCapture.width, canvasCapture.height);
            if (results.poseLandmarks) {
                drawConnectors(ctxCap, results.poseLandmarks, POSE_CONNECTIONS, {color: '#00FFCC', lineWidth: 2});
            }
            ctxCap.restore();

            // 3D Update
            if (results.poseLandmarks) {
                lineGroup.clear(); // Limpiamos líneas anteriores
                
                results.poseLandmarks.forEach((landmark, index) => {
                    const p = points3d[index];
                    // Normalización corregida: centramos y escalamos
                    p.position.x = (0.5 - landmark.x) * 2; 
                    p.position.y = (0.5 - landmark.y) * 2;
                    p.position.z = -landmark.z * 1.5;
                });

                // Dibujar conexiones en 3D
                POSE_CONNECTIONS.forEach(([startIdx, endIdx]) => {
                    const start = points3d[startIdx].position;
                    const end = points3d[endIdx].position;
                    const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
                    const line = new THREE.Line(geometry, lineMat);
                    lineGroup.add(line);
                });
            }

            renderer.render(scene, camera3d);
        }

        const holistic = new Holistic({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`});
        holistic.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5 });
        holistic.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => { await holistic.send({image: videoElement}); },
            width: 640, height: 480
        });
        camera.start();

        window.addEventListener('resize', () => {
            camera3d.aspect = container3d.clientWidth / container3d.clientHeight;
            camera3d.updateProjectionMatrix();
            renderer.setSize(container3d.clientWidth, container3d.clientHeight);
        });
    </script>
</body>
</html>
