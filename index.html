<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Gemini Ultra-Precision MoCap V9</title>
    <style>
        body { margin: 0; background-color: #00ff00; overflow: hidden; font-family: sans-serif; }
        #webcam { position: absolute; bottom: 20px; right: 20px; width: 220px; border: 2px solid #00d2ff; border-radius: 10px; transform: scaleX(-1); }
        #status { position: absolute; top: 20px; left: 20px; color: #fff; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 8px; border-left: 5px solid #00d2ff; }
    </style>
</head>
<body>
    <div id="status"><b>SISTEMA BIOMECÁNICO ACTIVO</b><br><span id="log">Sincronizando...</span></div>
    <video id="webcam" autoplay playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const log = document.getElementById('log');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x00ff00);

        const camera3D = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera3D.position.set(0, 0, 4); 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(0, 5, 10);
        scene.add(light, new THREE.AmbientLight(0xffffff, 0.4));

        // --- ESQUELETO ROBÓTICO AVANZADO ---
        const mat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.7, roughness: 0.2 });
        const matGlow = new THREE.MeshBasicMaterial({ color: 0x00d2ff });

        const torso = new THREE.Group();
        const pecho = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.7, 0.25), mat);
        torso.add(pecho);
        scene.add(torso);

        const cabeza = new THREE.Group();
        const craneo = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.3, 0.22), mat);
        const ojoD = new THREE.Mesh(new THREE.SphereGeometry(0.02, 8, 8), matGlow);
        const ojoI = ojoD.clone();
        ojoD.position.set(-0.07, 0.05, 0.11);
        ojoI.position.set(0.07, 0.05, 0.11);
        cabeza.add(craneo, ojoD, ojoI);
        scene.add(cabeza);

        function crearBrazo(lado) {
            const hombro = new THREE.Group();
            hombro.position.set(lado * 0.35, 0.3, 0);
            const sup = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.04, 0.4), mat);
            sup.position.y = -0.2;
            const codo = new THREE.Group();
            codo.position.y = -0.4;
            const inf = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.03, 0.4), mat);
            inf.position.y = -0.2;
            const mano = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.1, 0.04), matGlow);
            mano.position.y = -0.45;
            codo.add(inf, mano); hombro.add(sup, codo); torso.add(hombro);
            return { hombro, codo };
        }

        const brazoD = crearBrazo(-1);
        const brazoI = crearBrazo(1);

        // --- FILTRADO DE MOVIMIENTO (No más temblores) ---
        const lerp = (a, b, t) => a + (b - a) * t;
        const smoothV3 = (vCurrent, vTarget, t) => {
            vCurrent.x = lerp(vCurrent.x, vTarget.x, t);
            vCurrent.y = lerp(vCurrent.y, vTarget.y, t);
            vCurrent.z = lerp(vCurrent.z, vTarget.z, t);
        };

        const holistic = new Holistic({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`});
        holistic.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });

        holistic.onResults((res) => {
            if (!res.poseLandmarks) { log.innerText = "Buscando cuerpo..."; return; }
            log.innerText = "Tracking estable";
            
            const p = res.poseLandmarks;
            const f = res.faceLandmarks;

            const map = (pt) => new THREE.Vector3((pt.x - 0.5) * -3, (pt.y - 0.5) * -3, pt.z * -2);

            // 1. Torso y Cabeza (Fijos en profundidad para evitar el zoom que no te gustaba)
            const neckPos = map(p[0]);
            cabeza.position.set(neckPos.x, neckPos.y + 0.3, 0);
            torso.position.set(neckPos.x, neckPos.y - 0.4, 0);

            // Rotación de cabeza (Si miras a los lados, el robot también)
            if(f) {
                const faceTop = map(f[10]);
                const faceBottom = map(f[152]);
                const dir = new THREE.Vector3().subVectors(faceTop, faceBottom).normalize();
                cabeza.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
            }

            // 2. Brazos con Persistencia Anatomica
            updateArm(brazoD, map(p[11]), map(p[13]), map(p[15]), p[15].visibility);
            updateArm(brazoI, map(p[12]), map(p[14]), map(p[16]), p[16].visibility);
        });

        function updateArm(limb, h, c, w, vis) {
            if (vis < 0.5) return; // Si la cámara no está segura, el brazo se queda quieto (no desaparece)

            const dSup = new THREE.Vector3().subVectors(c, h).normalize();
            limb.hombro.quaternion.setFromUnitVectors(new THREE.Vector3(0, -1, 0), dSup);

            const dInf = new THREE.Vector3().subVectors(w, c).normalize();
            const localDInf = dInf.clone().applyQuaternion(limb.hombro.quaternion.clone().invert());
            limb.codo.quaternion.setFromUnitVectors(new THREE.Vector3(0, -1, 0), localDInf);
        }

        const camera = new Camera(document.getElementById('webcam'), {
            onFrame: async () => { await holistic.send({image: document.getElementById('webcam')}); },
            width: 1280, height: 720
        });
        camera.start();

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera3D);
        }
        animate();
    </script>
</body>
</html>
