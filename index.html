<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>AI Avatar - Hyper-Mesh 3D Engine</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', monospace; }
        #container { display: flex; width: 100vw; height: 100vh; }
        .view { flex: 1; border: 1px solid #222; position: relative; }
        video { position: absolute; width: 100%; height: 100%; object-fit: cover; opacity: 0.2; transform: rotateY(180deg); }
        .label { position: absolute; top: 10px; left: 10px; color: #00ffcc; z-index: 10; font-size: 12px; background: rgba(0,0,0,0.7); padding: 5px; border: 1px solid #00ffcc; }
    </style>
</head>
<body>
    <div id="container">
        <div class="view"><div class="label">INPUT_STREAM</div><video id="input_video"></video></div>
        <div class="view" id="three_view"><div class="label">3D_MESH_RENDER_v6</div></div>
    </div>

<script>
    const videoElement = document.getElementById('input_video');
    const container = document.getElementById('three_view');

    // --- CONFIGURACIÓN THREE.JS ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    const material = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.6 });

    // Creamos las partes del cuerpo como volúmenes
    const parts = {
        head: new THREE.Mesh(new THREE.IcosahedronGeometry(0.2, 2), material),
        torso: new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.2, 0.6, 8), material),
        lArm: new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.5, 6), material),
        rArm: new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.5, 6), material)
    };

    Object.values(parts).forEach(p => scene.add(p));
    camera.position.z = 2;

    function onResults(results) {
        if (!results.poseLandmarks) return;
        const lm = results.poseLandmarks;

        // Función para convertir MediaPipe a espacio 3D
        const to3D = (pt) => ({ x: (pt.x - 0.5) * 2.5, y: -(pt.y - 0.5) * 2.5, z: -pt.z * 2 });

        // Posicionar Cabeza
        const n = to3D(lm[0]);
        parts.head.position.set(n.x, n.y, n.z);

        // Posicionar Torso (entre hombros y cadera)
        const sL = to3D(lm[11]), sR = to3D(lm[12]);
        parts.torso.position.set((sL.x + sR.x)/2, sL.y - 0.3, 0);

        // Brazo Derecho (Cilindro que mira al codo)
        const eR = to3D(lm[14]);
        const armVec = new THREE.Vector3(eR.x - sR.x, eR.y - sR.y, eR.z - sR.z);
        parts.rArm.position.set(sR.x + armVec.x/2, sR.y + armVec.y/2, sR.z + armVec.z/2);
        parts.rArm.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), armVec.clone().normalize());

        renderer.render(scene, camera);
    }

    const holistic = new Holistic({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`});
    holistic.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.6 });
    holistic.onResults(onResults);

    const cam = new Camera(videoElement, {
        onFrame: async () => { await holistic.send({image: videoElement}); },
        width: 640, height: 480
    });
    cam.start();
</script>
</body>
</html>
