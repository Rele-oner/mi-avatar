<!DOCTYPE html>
<html>
<head>
    <title>Avatar Pro - Estabilidad Máxima</title>
    <style>
        body { margin: 0; background-color: #00ff00; overflow: hidden; }
        #webcam { position: absolute; bottom: 10px; right: 10px; width: 140px; transform: scaleX(-1); border: 2px solid #00ff00; border-radius: 8px; opacity: 0.4; }
        #status { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.85); padding: 12px; font-family: sans-serif; border-radius: 10px; border-left: 5px solid #ff4757; }
        .btn-reset { padding: 10px 15px; background: #2f3542; color: white; border: 1px solid #57606f; border-radius: 5px; cursor: pointer; margin-top: 5px; font-weight: bold; }
    </style>
</head>
<body>
    <div id="status">
        <b>ESTADO:</b> CALIBRANDO...<br>
        <button class="btn-reset" onclick="location.reload()">REINICIAR MOTOR</button>
    </div>
    <video id="webcam" autoplay playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const videoElement = document.getElementById('webcam');
        const statusText = document.getElementById('status');

        // ESCENA 3D MEJORADA
        const scene = new THREE.Scene();
        const camera3D = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const material = new THREE.MeshNormalMaterial();
        const avatar = new THREE.Group();

        // Construcción robusta
        const cabeza = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.4, 0.25), material);
        const tronco = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.7, 0.2), material);
        tronco.position.y = -0.6;
        avatar.add(cabeza, tronco);

        function crearMiembro(x) {
            const hombro = new THREE.Group();
            hombro.position.set(x, -0.3, 0);
            const sup = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.03, 0.4), material);
            sup.geometry.translate(0, -0.2, 0);
            const codo = new THREE.Group();
            codo.position.y = -0.4;
            const inf = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.02, 0.4), material);
            inf.geometry.translate(0, -0.2, 0);
            const mano = new THREE.Group();
            mano.position.y = -0.4;
            codo.add(inf, mano);
            hombro.add(sup, codo);
            return { hombro, codo, mano };
        }

        const bDer = crearMiembro(-0.3);
        const bIzq = crearMiembro(0.3);
        avatar.add(bDer.hombro, bIzq.hombro);
        scene.add(avatar);
        camera3D.position.set(0, -0.4, 2.8);

        // FILTRO DE SUAVIZADO (LERP)
        const suavizar = (actual, objetivo, factor) => THREE.MathUtils.lerp(actual, objetivo, factor);

        const holistic = new Holistic({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`});
        holistic.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });

        holistic.onResults((res) => {
            if (res.faceLandmarks) {
                statusText.innerHTML = "<b>SISTEMA:</b> CONECTADO<br><small>Pose-T para mejor precisión</small>";
                const n = res.faceLandmarks[1];
                cabeza.rotation.y = suavizar(cabeza.rotation.y, (n.x - 0.5) * -1.2, 0.1);
                cabeza.rotation.x = suavizar(cabeza.rotation.x, (n.y - 0.5) * 1.2, 0.1);
            }

            if (res.poseLandmarks) {
                controlarBrazo(res.poseLandmarks[11], res.poseLandmarks[13], res.poseLandmarks[15], bDer, -1);
                controlarBrazo(res.poseLandmarks[12], res.poseLandmarks[14], res.poseLandmarks[16], bIzq, 1);
            }
        });

        function controlarBrazo(h, c, m, obj, lado) {
            // Solo movemos si la confianza es alta
            if (h.visibility > 0.7 && c.visibility > 0.7) {
                const angH = Math.atan2(c.y - h.y, (c.x - h.x) * lado) + Math.PI/2;
                obj.hombro.rotation.z = suavizar(obj.hombro.rotation.z, angH * lado, 0.15);
                
                const angC = Math.atan2(m.y - c.y, (m.x - c.x) * lado) - angH + Math.PI/2;
                // Limitador físico del codo (no permitir ángulos imposibles)
                const angCLimitado = Math.max(-2, Math.min(2, angC));
                obj.codo.rotation.z = suavizar(obj.codo.rotation.z, angCLimitado * lado, 0.15);
            } else {
                // Posición de reposo si se pierde el tracking
                obj.hombro.rotation.z = suavizar(obj.hombro.rotation.z, 0.2 * -lado, 0.05);
                obj.codo.rotation.z = suavizar(obj.codo.rotation.z, 0, 0.05);
            }
        }

        const camera = new Camera(videoElement, {
            onFrame: async () => { await holistic.send({image: videoElement}); },
            width: 1280, height: 720
        });
        camera.start();

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera3D);
        }
        animate();
    </script>
</body>
</html>
