<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Croma Avatar - Fixed Scale V8</title>
    <style>
        body { margin: 0; background-color: #00ff00; overflow: hidden; }
        #webcam { position: absolute; bottom: 10px; right: 10px; width: 200px; transform: scaleX(-1); border-radius: 8px; border: 1px solid white; z-index: 100; }
    </style>
</head>
<body>
    <video id="webcam" autoplay playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const videoElement = document.getElementById('webcam');

        // --- RENDER CON BLOQUEO DE CÁMARA ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x00ff00); // Croma estable

        const camera3D = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Fijamos la cámara para evitar el efecto "zoom" que viste
        camera3D.position.set(0, 0, 4);
        camera3D.lookAt(0, 0, 0);

        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(0, 5, 10);
        scene.add(light, new THREE.AmbientLight(0xffffff, 0.5));

        // --- MODELO ROBÓTICO ---
        const matRobot = new THREE.MeshPhongMaterial({ color: 0x111111 });
        const matJoint = new THREE.MeshPhongMaterial({ color: 0x00d2ff, emissive: 0x00d2ff });

        const torso = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.8, 0.2), matRobot);
        const cabeza = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.35, 0.25), matRobot);
        scene.add(torso, cabeza);

        function crearExtremidad(lado) {
            const hombro = new THREE.Group();
            hombro.position.set(lado * 0.35, 0.3, 0);
            const sup = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.05, 0.4), matRobot);
            sup.position.y = -0.2;
            const codo = new THREE.Group();
            codo.position.y = -0.4;
            const inf = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.04, 0.4), matRobot);
            inf.position.y = -0.2;
            const mano = new THREE.Mesh(new THREE.SphereGeometry(0.07, 16, 16), matJoint);
            mano.position.y = -0.4;
            codo.add(inf, mano); hombro.add(sup, codo); torso.add(hombro);
            return { hombro, codo };
        }

        const brazoD = crearExtremidad(-1);
        const brazoI = crearExtremidad(1);

        // --- LÓGICA DE SEGUIMIENTO FIJA ---
        const holistic = new Holistic({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`});
        holistic.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });

        holistic.onResults((res) => {
            if (!res.poseLandmarks) return;
            const p = res.poseLandmarks;

            // Convertir coordenadas con escala estática (el 0.5 centra el avatar)
            const toV = (pt) => new THREE.Vector3((pt.x - 0.5) * -3, (pt.y - 0.5) * -3, 0);

            // Cabeza y Torso se mueven pero NO se acercan a la cámara
            const nariz = toV(p[0]);
            cabeza.position.set(nariz.x, nariz.y + 0.3, 0);
            torso.position.set(nariz.x, nariz.y - 0.4, 0);

            // Brazos: Solo rotan, nunca se estiran fuera de su anclaje
            resolverIK(brazoD, toV(p[11]), toV(p[13]), toV(p[15]));
            resolverIK(brazoI, toV(p[12]), toV(p[14]), toV(p[16]));
        });

        function resolverIK(limb, h, c, m) {
            const dirSup = new THREE.Vector3().subVectors(c, h).normalize();
            limb.hombro.quaternion.setFromUnitVectors(new THREE.Vector3(0, -1, 0), dirSup);
            const dirInf = new THREE.Vector3().subVectors(m, c).normalize();
            const localDir = dirInf.applyQuaternion(limb.hombro.quaternion.clone().invert());
            limb.codo.quaternion.setFromUnitVectors(new THREE.Vector3(0, -1, 0), localDir);
        }

        const camera = new Camera(videoElement, {
            onFrame: async () => { await holistic.send({image: videoElement}); },
            width: 1280, height: 720
        });
        camera.start();

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera3D);
        }
        animate();
    </script>
</body>
</html>
